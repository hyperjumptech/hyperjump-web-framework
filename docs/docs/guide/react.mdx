---
title: React
---

<Callout type="warn" title="Prerequisite">
  Before reading this guide, you should be familiar with React. Please read
  **every single page** in the [React documentation](https://react.dev).
</Callout>

In this page we lay out some conventions to follow when developing a React application in Hyperjump so that the code is easier to understand and test.

## Do not use useEffect unnecessarily

One of the most common newbie mistakes when using React is to use `useEffect` unnecessarily. There's even a page in React documentation that explains [that you might not need an Effect](https://react.dev/learn/you-might-not-need-an-effect). Please read it thoroughly.

Let's see a bad example:

```tsx title="component.tsx" lineNumbers
const Component = () => {
  const [data, setData] = useState<string[]>([]);
  const [message, setMessage] = useState<string>("");

  useEffect(() => {
    setMessage(`Hello, ${data.join(", ")}!`);
  }, [data]);

  const handleClick = () => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => {
        setData(data);
      });
  };

  return (
    <div>
      <p>{message}</p>
      <button onClick={handleClick}>Fetch Data</button>
    </div>
  );
};
```

In that example, the `message` state and the effect to update the message are not necessary (line 3-7). The `message` variable can be computed from the `data` state using a simple expression as follows:

```tsx title="component.tsx" lineNumbers
const Component = () => {
  const [data, setData] = useState<string[]>([]);

  const message = `Hello, ${data.join(", ")}!`;

  const handleClick = () => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => {
        setData(data);
      });
  };

  return (
    <div>
      <p>{message}</p>
      <button onClick={handleClick}>Fetch Data</button>
    </div>
  );
};
```

<Callout type="info" title="Rule of thumb">
  If a "state" can be computed, do not use Effect to update it.
</Callout>

## Always encapsulate the logic in a custom hooks

If you look at a React component, e.g., the `component.tsx` in the previous example, we can actually see that it has two parts:

- The code that constructs the UI. This is the JSX code that is returned by the component.
- The logic that is used to update the state and run effects. This is every line of code from the opening curly brace `{` to the `return` statement.

As experience has shown, when we have so many lines of code in the logic part, it is difficult to understand and test. Imagine if we have a component with 100 lines of code in the logic part. It takes more time and effort to even find where the UI part is.

In the example above, we can encapsulate the logic in a custom hook as follows:

```tsx title="use-data.ts" lineNumbers
const useData = () => {
  const [data, setData] = useState<string[]>([]);

  const fetchData = useCallback(() => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => {
        setData(data);
      });
  }, []);

  const message = `Hello, ${data.join(", ")}!`;

  return useMemo(
    () => ({ data, fetchData, message }),
    [data, fetchData, message]
  );
};
```

<Callout type="info" title="Good to know">
  The name of the custom hook has to be prefixed with `use`. This will help
  react's hook linter to lint the custom hooks to follow the [rule of
  hooks](https://react.dev/reference/rules/rules-of-hooks).
</Callout>

<Callout type="info" title="Good to know">
  Once React compiler is stable and available by default in Next.js, we won't
  need the `useCallback` and `useMemo` anymore.
</Callout>

Then we can use the custom hook in the component as follows:

```tsx title="component.tsx" lineNumbers
const Component = () => {
  const { data, fetchData, message } = useData();

  return (
    <div>
      <p>{message}</p>
      <button onClick={fetchData}>Fetch Data</button>
    </div>
  );
};
```

As you can see, the component is now much simpler and easier to understand. The logic is encapsulated in the custom hook and the component is only responsible for the UI. It is also easier to understand the logic. We understand immediately from its name (`useData`) that the custom hook is to fetch the data, and simply return both the data and the message.

<Callout type="info" title="Rule of thumb">
  A React component **must not** have any `useState` and `useEffect` statements.
  All the state management and effect handling should be encapsulated in custom
  hooks.
</Callout>

## Do not create inline functions as component

Another common mistake that makes a component hard to understand is to create inline functions that return JSX. Let's see a bad example:

```tsx title="tabs.tsx" lineNumbers
const Tabs = ({ title }: { title: string }) => {
  const createTab = (label: string) => {
    return (
      <div>
        <p>
          {title}:{label}
        </p>
      </div>
    );
  };

  return (
    <div>
      {createTab("Tab 1")}
      {createTab("Tab 2")}
      {createTab("Tab 3")}
    </div>
  );
};
```

In that example, the `createTab` function pollutes the `Tabs` component. It has nothing to do with the `Tabs` component. Imagine if the function has hundreds of lines of code. It is difficult to understand what it is for.

The `createTab` function is essentially a React functional component since it returns JSX. It's so much better to define it as a separate component as follows:

```tsx title="tab.tsx" lineNumbers
const Tab = ({ title, label }: { title: string; label: string }) => {
  return (
    <div>
      <p>
        {title}:{label}
      </p>
    </div>
  );
};
```

Then we can use the `Tab` component in the `Component` component as follows:

```tsx title="component.tsx" lineNumbers
const Component = ({ title }: { title: string }) => {
  return (
    <div>
      <Tab title={title} label="Tab 1" />
      <Tab title={title} label="Tab 2" />
      <Tab title={title} label="Tab 3" />
    </div>
  );
};
```

Now, not only the `Tabs` component is much simpler and easier to understand, but also the `Tab` component is a separate component and it is easier to understand what it is for.

<Callout type="info" title="Rule of thumb">
  Do not create inline functions that return JSX. Instead, create a named
  function and use it.
</Callout>

## Use HOC aggresively

Concretely, a higher-order component (HOC) is a function that takes a component and returns a new component. This is another way to keep the components clean and modular just like the custom hooks.

Let's see a very simple example. Say we have a component that displays a "Logout" button when the user is logged in and a "Login" button when the user is not logged in. Usually, we would write a component like this:

```tsx title="auth-button.tsx" lineNumbers
const AuthButton = () => {
  const isLoggedIn = useIsLoggedIn();
  return (
    <div>{isLoggedIn ? <button>Logout</button> : <button>Login</button>}</div>
  );
};
```

We already use a custom hook, which is great! But the problem with this approach is that the `AuthButton` component still needs to actively "get" a piece of data (`isLoggedIn` in this example) to correctly render the component. We can make this component ~dumber~ simpler by removing the custom hook call and instead pass the `isLoggedIn` data as a prop to the component.

```tsx title="auth-button.tsx" lineNumbers
const AuthButton = ({ isLoggedIn }: { isLoggedIn: boolean }) => {
  return (
    <div>{isLoggedIn ? <button>Logout</button> : <button>Login</button>}</div>
  );
};
```

Now the `AuthButton` component **only focuses on rendering the buttons conditionally**. But how do we get the `isLoggedIn` data? We can create a higher-order function to do this.

```tsx title="with-auth.tsx" lineNumbers
import { useIsLoggedIn } from "../hooks/use-is-logged-in";
import type { ComponentProps } from "react";

export const withAuth = <T extends ComponentProps<"div">>(
  Component: React.ComponentType<T & { isLoggedIn: boolean }>
) => {
  const WithAuth = (props: T) => {
    const isLoggedIn = useIsLoggedIn();
    return <Component {...props} isLoggedIn={isLoggedIn} />;
  };
  type WithoutAuthProps = Omit<T, "isLoggedIn">;
  return WithAuth as React.ComponentType<WithoutAuthProps>;
};
```

Then we can use the `withAuth` higher-order function to wrap the `AuthButton` component as follows:

```tsx title="component.tsx" lineNumbers
export default withAuth(AuthButton);
```

The great thing about this approach is that we can now create another new component that needs `isLoggedIn` data as a prop by simply wrapping the component with the `withAuth` higher-order function.

## Prevent impossible states

The following is a bad code. Can you tell why?

```tsx title="component.tsx" lineNumbers
const MyComponent = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(false);
  const [success, setSuccess] = useState(false);

  return (
    <div>
      {loading && !error && !success && <p>Loading...</p>}
      {error && !loading && !success && <p>Error occurred</p>}
      {success && !loading && !error && <p>Operation completed successfully</p>}
    </div>
  );
};
```

The code above is bad because it doesn't prevent impossible states from happening. For example, `loading` can be true while `success` is true. What we want is actually an exclusive state machine: of all three states, only one can be true at any given time, like this:

```tsx title="component.tsx" lineNumbers
import { useState } from "react";

type State = "loading" | "error" | "success";

const useStateMachine = () => {
  const [state, setState] = useState<State>("loading");

  const handleClick = () => {
    setState("loading");
    // Simulate an async operation
    setTimeout(() => {
      setState("success");
    }, 2000);
  };

  return { state, handleClick };
};

const MyComponent = () => {
  const { state, handleClick } = useStateMachine();

  return (
    <div>
      {state === "loading" && <p>Loading...</p>}
      {state === "error" && <p>Error occurred</p>}
      {state === "success" && <p>Operation completed successfully</p>}
      <button onClick={handleClick}>Click me</button>
    </div>
  );
};
```

## Controlled and uncontrolled components in a form

It is very common to use a state to store the value of an input in a form like this:

```tsx title="component.tsx" lineNumbers
const MyComponent = () => {
  const [value, setValue] = useState("");

  return (
    <input
      type="text"
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
};
```

Now imagine we have 10 or more inputs in the form. We will have to create 10 or more state variables to store the value of each input. It could get messy quickly.

When your input field has `value` property and `onChange` handler, it becomes a **controlled component**. Before turning inputs in a form into controlled components, you should ask yourself if you need it to be controlled because adding states adds complexity, introduces potential bugs, more code in the bundle, and more CPU cycles.

These are some cases where you think you need to use controlled inputs but you might not need it.

### Collecting input values

One of the common cases to use controlled inputs is to collect the input values and send to an API route like this:

```tsx title="component.tsx" lineNumbers
const MyComponent = () => {
  const [value, setValue] = useState("");

  const handleSubmit = async () => {
    await fetchData({
      body: { value },
    });
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={value}
          onChange={(e) => setValue(e.target.value)}
        />
        <button type="submit">Submit</button>
      </form>
    </div>
  );
};
```

However, if we are using a server function to handle the form submission, we don't need to use controlled inputs.

```tsx title="component.tsx" lineNumbers
import { useActionState } from "react";
import { serverFunction } from "./some-server-function";

const MyComponent = () => {
  const [state, action, pending] = useActionState(serverFunction, null);
  return (
    <div>
      <form action={action}>
        <input type="text" name="username" />
        <button type="submit">Submit</button>
      </form>
    </div>
  );
};
```

```ts title="some-server-function.ts" lineNumbers
export const serverFunction = async (formData: FormData) => {
  const username = formData.get("username");
  return { username };
};
```

As you can see, we just need to make sure that every input field has a `name` attribute so that the server function can extract the value of the input field from the form data.

<Callout type="info" title="Good to know">
  For more information on using server functions, please refer to the [Updating
  Data](../guide/updating-data.mdx) guide.
</Callout>

### Input validation

Another common case to use controlled inputs is to validate the input values before sending data to the server. Here's some things you should consider before turning your input fields into controlled components.

1. Your server side code, whether it's a server function or a route handler, will validate the input values anyway because **data from external sources must always be validated**. So consider if it's acceptable to validate the inputs in the server and simply show the validation errors in the client if any.
2. The modern browser has built-in validation for input fields. For example, if you use the `required` attribute, the browser will show a validation error if the input field is empty. Of if you add `type="email"`, the browser will show a validation error if the input field is not a valid email address. Consider the built-in HTML attributes like [pattern](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/pattern), [minLength](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/minlength), [required](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/required), input [type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input/email), etc.
3. For validation rules that are not supported natively by the browser, consider using [useResettableActionState](https://github.com/nicnocquee/use-resettable-action-state) to validate the input values before data is sent to a server function. For example, you might want to make sure two input fields have the same value (e.g., password and confirm password) like this:

```tsx title="component.tsx" lineNumbers
"use client";
import { doSomething } from "./actions";
import { useResettableActionState } from "use-resettable-action-state";

export default function Form({
  initialState,
}: {
  initialState: { password: string | null; error: string | null };
}) {
  const [state, submit, isPending, reset, payload] = useResettableActionState(
    doSomething,
    initialState,
    undefined,
    async (payload, abortController) => {
      if (payload?.get("password") !== payload?.get("repeat-password")) {
        abortController.abort({
          error: "Passwords do not match",
        });
      }
      return payload;
    }
  );

  return (
    <form action={submit}>
      {state && !state.error && <p>Success!</p>}
      {state && state.error && (
        <p className="bg-red-500 text-white p-4">{state.error}</p>
      )}
      <input
        type="password"
        name="password"
        id="password"
        placeholder="Enter new password"
      />
      <input
        type="password"
        name="repeat-password"
        id="repeat-password"
        placeholder="Repeat the new password"
      />
      <p>{state && state.data?.message}</p>

      <button disabled={isPending} type="submit">
        {isPending ? "Loading..." : "Submit"}
      </button>
    </form>
  );
}
```

Use controlled inputs when all three conditions above are not met.

### Using third party form libraries

There are many third party form libraries that can help you manage forms in a more declarative way. For example, [React Hook Form](https://react-hook-form.com/) and [Formik](https://formik.org/).

#### When to use third party form libraries

1. Real time / instant validation of input values.

There are cases where an input value is required to be validated immediately without having to wait for the user to submit the form. For example:

```tsx title="email-form.tsx" lineNumbers
"use client";

import { useForm } from "react-hook-form";
import { useState } from "react";

// Server function to check if email exists
async function checkEmailExists(email: string): Promise<boolean> {
  const response = await fetch("/api/check-email", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email }),
  });
  const data = await response.json();
  return data.exists;
}

export default function EmailForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isValidating },
    setError,
    clearErrors,
  } = useForm();
  const [isCheckingEmail, setIsCheckingEmail] = useState(false);

  const validateEmail = async (email: string) => {
    if (!email) return "Email is required";

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return "Invalid email format";
    }

    setIsCheckingEmail(true);
    try {
      const exists = await checkEmailExists(email);
      if (exists) {
        return "This email is already registered";
      }
      return true;
    } catch (error) {
      return "Failed to validate email";
    } finally {
      setIsCheckingEmail(false);
    }
  };

  const onSubmit = async (data: any) => {
    // Send the payload to the server
    await fetch("/api/check-email", {
      method: "POST",
      body: JSON.stringify(data),
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          id="email"
          type="email"
          {...register("email", {
            validate: validateEmail,
          })}
          className={`mt-1 block w-full rounded-md border ${
            errors.email ? "border-red-500" : "border-gray-300"
          } px-3 py-2`}
        />
        {isCheckingEmail && (
          <p className="mt-1 text-sm text-gray-500">Checking email...</p>
        )}
        {errors.email && (
          <p className="mt-1 text-sm text-red-600">
            {errors.email.message as string}
          </p>
        )}
      </div>
      <button
        type="submit"
        disabled={isValidating || isCheckingEmail}
        className="rounded-md bg-blue-500 px-4 py-2 text-white hover:bg-blue-600 disabled:opacity-50"
      >
        {isValidating || isCheckingEmail ? "Validating..." : "Submit"}
      </button>
    </form>
  );
}
```

The example above validates if the email is not duplicated with the existing emails in the database. This is a good use case for third party form libraries, as it can show the validation error UI feedbacks such as red borders, error message, etc. immediately without having to wait for the user to submit the form.

2. Conditional rendering of input fields.

There are cases where you want to conditionally render an input field based on the value of another input field. For example, take a look at this case of activity creation form:

a. There is a field called `type`.
b. The value of `type` is either "event", "regular", and "project"

- If the value of `type` is "event", then there should be an array of fields for the event dates.
- If the value of `type` is "regular", then there should be an array of fields for the regular schedules per day, along with the start and end time of the whole activity period.
- If the value of `type` is "project", then there should be a field for the start and end date of the project.

```tsx title="activity-form.tsx" lineNumbers
"use client";

import { useForm, useFieldArray } from "react-hook-form";

type ActivityType = "event" | "regular" | "project";

interface ActivityFormData {
  name: string;
  type: ActivityType;
  // Event fields
  eventDates?: { date: string }[];
  // Regular fields
  regularSchedules?: {
    day: string;
    startTime: string;
    endTime: string;
  }[];
  activityStartDate?: string;
  activityEndDate?: string;
  // Project fields
  projectStartDate?: string;
  projectEndDate?: string;
}

export default function ActivityForm() {
  const { register, control, watch, handleSubmit } = useForm<ActivityFormData>({
    defaultValues: {
      name: "",
      type: "event",
      eventDates: [{ date: "" }],
      regularSchedules: [{ day: "Monday", startTime: "", endTime: "" }],
    },
  });

  const activityType = watch("type");

  const {
    fields: eventDateFields,
    append: appendEventDate,
    remove: removeEventDate,
  } = useFieldArray({
    control,
    name: "eventDates",
  });

  const {
    fields: scheduleFields,
    append: appendSchedule,
    remove: removeSchedule,
  } = useFieldArray({
    control,
    name: "regularSchedules",
  });

  const onSubmit = (data: ActivityFormData) => {
    console.log("Form submitted:", data);
    // Remove the unnecessary fields from the payload
    switch (activityType) {
      case "event":
        return {
          name: data.name,
          eventDates: data.eventDates,
        };
      case "regular":
        return {
          name: data.name,
          regularSchedules: data.regularSchedules,
          activityStartDate: data.activityStartDate,
          activityEndDate: data.activityEndDate,
        };
      case "project":
        return {
          name: data.name,
          projectStartDate: data.projectStartDate,
          projectEndDate: data.projectEndDate,
        };
    }

    // Send the payload to the server
    await fetch("/api/activities", {
      method: "POST",
      body: JSON.stringify(payload),
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="name" className="block text-sm font-medium">
          Activity Name
        </label>
        <input
          id="name"
          {...register("name", { required: true })}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      <div>
        <label htmlFor="type" className="block text-sm font-medium">
          Activity Type
        </label>
        <select
          id="type"
          {...register("type")}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        >
          <option value="event">Event</option>
          <option value="regular">Regular</option>
          <option value="project">Project</option>
        </select>
      </div>

      {/* Conditional fields based on activity type */}
      {activityType === "event" && (
        <div className="space-y-2">
          <label className="block text-sm font-medium">Event Dates</label>
          {eventDateFields.map((field, index) => (
            <div key={field.id} className="flex gap-x-2 gap-y-2">
              <input
                type="date"
                {...register(`eventDates.${index}.date` as const)}
                className="block w-full rounded-md border border-gray-300 px-3 py-2"
              />
              <button
                type="button"
                onClick={() => removeEventDate(index)}
                className="rounded-md bg-red-500 px-3 py-2 text-white hover:bg-red-600"
              >
                Remove
              </button>
            </div>
          ))}
          <button
            type="button"
            onClick={() => appendEventDate({ date: "" })}
            className="rounded-md bg-green-500 px-3 py-2 text-white hover:bg-green-600"
          >
            Add Event Date
          </button>
        </div>
      )}

      {activityType === "regular" && (
        <div className="space-y-4">
          <div className="grid grid-cols-2 gap-x-4 gap-y-2">
            <div>
              <label className="block text-sm font-medium">
                Activity Start Date
              </label>
              <input
                type="date"
                {...register("activityStartDate")}
                className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
              />
            </div>
            <div>
              <label className="block text-sm font-medium">
                Activity End Date
              </label>
              <input
                type="date"
                {...register("activityEndDate")}
                className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
              />
            </div>
          </div>

          <div className="space-y-2">
            <label className="block text-sm font-medium">
              Regular Schedules
            </label>
            {scheduleFields.map((field, index) => (
              <div key={field.id} className="space-y-2 rounded border p-3">
                <div className="grid grid-cols-3 gap-x-2 gap-y-2">
                  <select
                    {...register(`regularSchedules.${index}.day` as const)}
                    className="rounded-md border border-gray-300 px-3 py-2"
                  >
                    <option value="Monday">Monday</option>
                    <option value="Tuesday">Tuesday</option>
                    <option value="Wednesday">Wednesday</option>
                    <option value="Thursday">Thursday</option>
                    <option value="Friday">Friday</option>
                    <option value="Saturday">Saturday</option>
                    <option value="Sunday">Sunday</option>
                  </select>
                  <input
                    type="time"
                    {...register(
                      `regularSchedules.${index}.startTime` as const
                    )}
                    className="rounded-md border border-gray-300 px-3 py-2"
                  />
                  <input
                    type="time"
                    {...register(`regularSchedules.${index}.endTime` as const)}
                    className="rounded-md border border-gray-300 px-3 py-2"
                  />
                </div>
                <button
                  type="button"
                  onClick={() => removeSchedule(index)}
                  className="rounded-md bg-red-500 px-3 py-2 text-sm text-white hover:bg-red-600"
                >
                  Remove Schedule
                </button>
              </div>
            ))}
            <button
              type="button"
              onClick={() =>
                appendSchedule({ day: "Monday", startTime: "", endTime: "" })
              }
              className="rounded-md bg-green-500 px-3 py-2 text-white hover:bg-green-600"
            >
              Add Schedule
            </button>
          </div>
        </div>
      )}

      {activityType === "project" && (
        <div className="grid grid-cols-2 gap-x-4 gap-y-2">
          <div>
            <label className="block text-sm font-medium">
              Project Start Date
            </label>
            <input
              type="date"
              {...register("projectStartDate")}
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
            />
          </div>
          <div>
            <label className="block text-sm font-medium">
              Project End Date
            </label>
            <input
              type="date"
              {...register("projectEndDate")}
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
            />
          </div>
        </div>
      )}

      <button
        type="submit"
        className="rounded-md bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
      >
        Create Activity
      </button>
    </form>
  );
}
```

This is a good use case for third party form libraries, as it can handle the conditional rendering of input fields and preprocess the payload data before sending it to the server.

3. Dynamic form arrays

There are cases where you want to dynamically add or remove input fields in a form. For example, take a look at this case of inputting divisions in an activity creation form:

a. There is a field called `divisions`.
b. The value of `divisions` is an array of objects.
c. Each object has a `name`, `description`, and `number_of_volunteers_needed` fields.
d. The user can add or remove divisions by clicking a button.

```tsx title="divisions-form.tsx" lineNumbers
"use client";

import { useForm, useFieldArray } from "react-hook-form";

interface Division {
  name: string;
  description: string;
  number_of_volunteers_needed: number;
}

interface DivisionsFormData {
  activityName: string;
  divisions: Division[];
}

export default function DivisionsForm() {
  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<DivisionsFormData>({
    defaultValues: {
      activityName: "",
      divisions: [
        {
          name: "",
          description: "",
          number_of_volunteers_needed: 0,
        },
      ],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "divisions",
  });

  const onSubmit = async (data: DivisionsFormData) => {
    // Preprocess the payload before sending to server
    const payload = {
      activityName: data.activityName,
      divisions: data.divisions.filter(
        (division) =>
          division.name.trim() !== "" &&
          division.number_of_volunteers_needed > 0
      ),
    };

    console.log("Processed payload:", payload);

    // Send to server
    await fetch("/api/activities", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div>
        <label htmlFor="activityName" className="block text-sm font-medium">
          Activity Name
        </label>
        <input
          id="activityName"
          {...register("activityName", {
            required: "Activity name is required",
          })}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
        {errors.activityName && (
          <p className="mt-1 text-sm text-red-600">
            {errors.activityName.message}
          </p>
        )}
      </div>

      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium">Divisions</h3>
          <button
            type="button"
            onClick={() =>
              append({
                name: "",
                description: "",
                number_of_volunteers_needed: 0,
              })
            }
            className="rounded-md bg-blue-500 px-4 py-2 text-sm text-white hover:bg-blue-600"
          >
            Add Division
          </button>
        </div>

        {fields.map((field, index) => (
          <div
            key={field.id}
            className="space-y-3 rounded-lg border border-gray-200 bg-gray-50 p-4"
          >
            <div className="flex items-center justify-between">
              <h4 className="font-medium text-gray-700">
                Division {index + 1}
              </h4>
              <button
                type="button"
                onClick={() => remove(index)}
                disabled={fields.length === 1}
                className="rounded-md bg-red-500 px-3 py-1 text-sm text-white hover:bg-red-600 disabled:cursor-not-allowed disabled:opacity-50"
              >
                Remove
              </button>
            </div>

            <div>
              <label
                htmlFor={`divisions.${index}.name`}
                className="block text-sm font-medium"
              >
                Division Name
              </label>
              <input
                id={`divisions.${index}.name`}
                {...register(`divisions.${index}.name` as const, {
                  required: "Division name is required",
                })}
                className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
                placeholder="e.g., Registration Team"
              />
              {errors.divisions?.[index]?.name && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.divisions[index]?.name?.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor={`divisions.${index}.description`}
                className="block text-sm font-medium"
              >
                Description
              </label>
              <textarea
                id={`divisions.${index}.description`}
                {...register(`divisions.${index}.description` as const, {
                  required: "Description is required",
                })}
                rows={3}
                className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
                placeholder="Describe the division's responsibilities..."
              />
              {errors.divisions?.[index]?.description && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.divisions[index]?.description?.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor={`divisions.${index}.number_of_volunteers_needed`}
                className="block text-sm font-medium"
              >
                Number of Volunteers Needed
              </label>
              <input
                id={`divisions.${index}.number_of_volunteers_needed`}
                type="number"
                {...register(
                  `divisions.${index}.number_of_volunteers_needed` as const,
                  {
                    required: "Number of volunteers is required",
                    min: {
                      value: 1,
                      message: "At least 1 volunteer is required",
                    },
                    valueAsNumber: true,
                  }
                )}
                className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
                placeholder="0"
              />
              {errors.divisions?.[index]?.number_of_volunteers_needed && (
                <p className="mt-1 text-sm text-red-600">
                  {
                    errors.divisions[index]?.number_of_volunteers_needed
                      ?.message
                  }
                </p>
              )}
            </div>
          </div>
        ))}

        {fields.length === 0 && (
          <p className="text-center text-sm text-gray-500">
            No divisions added yet. Click "Add Division" to get started.
          </p>
        )}
      </div>

      <div className="flex justify-end gap-x-3 gap-y-2">
        <button
          type="button"
          onClick={() => {
            // Reset form or navigate away
          }}
          className="rounded-md border border-gray-300 bg-white px-4 py-2 text-gray-700 hover:bg-gray-50"
        >
          Cancel
        </button>
        <button
          type="submit"
          className="rounded-md bg-green-500 px-4 py-2 text-white hover:bg-green-600"
        >
          Create Activity
        </button>
      </div>
    </form>
  );
}
```

This is a good use case for third party form libraries, as it can handle the dynamic form arrays and preprocess the payload data before sending it to the server.

#### Hybrid approach between third party form libraries and server functions

You can use a hybrid approach between third party form libraries and server functions. For example, you can use React Hook Form to handle the client side validation, and call the server function to handle the server side validation and data processing.

```tsx title="registration-form.tsx" lineNumbers
// Client Component
"use client";

import { useForm } from "react-hook-form";
import { toast } from "sonner";
import { useEffect } from "react";
import { registerUser } from "./actions"; // This is the server function
import FormSchema from "./form-schema";

interface RegistrationFormData {
  name: string;
  email: string;
  password: string;
  confirmPassword: string;
  recaptcha: string;
}

export default function RegistrationForm() {
  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isSubmitting },
  } = useForm<RegistrationFormData>();

  const password = watch("password");

  useEffect(() => {
    // Load reCAPTCHA script
    const script = document.createElement("script");
    script.src = "https://www.google.com/recaptcha/api.js?render=YOUR_SITE_KEY";
    script.async = true;
    document.body.appendChild(script);

    return () => {
      document.body.removeChild(script);
    };
  }, []);

  // React Hook Form will handle the submit event
  const onSubmit = async (data: RegistrationFormData) => {
    try {
      // Execute reCAPTCHA
      const token = await window.grecaptcha.execute("YOUR_SITE_KEY", {
        action: "register",
      });

      // Set the reCAPTCHA token
      const dataWithRecaptcha = {
        ...data,
        recaptcha: token,
      };

      // Validate the input values in the client side first
      const validatedData = FormSchema.safeParse(dataWithRecaptcha);
      if (!validatedData.success) {
        toast.error(validatedData.error.message);
        return;
      }

      // If valid, call the server function
      await registerUser(validatedData.data);
      toast.success("Registration successful!");
    } catch (error) {
      toast.error("Registration failed. Please try again.");
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="name" className="block text-sm font-medium">
          Name
        </label>
        <input
          id="name"
          type="text"
          {...register("name", {
            required: "Name is required",
            minLength: {
              value: 2,
              message: "Name must be at least 2 characters",
            },
          })}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
        {errors.name && (
          <p className="mt-1 text-sm text-red-600">{errors.name.message}</p>
        )}
      </div>

      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          id="email"
          type="email"
          {...register("email", {
            required: "Email is required",
            pattern: {
              value: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
              message: "Invalid email format",
            },
          })}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
        {errors.email && (
          <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
        )}
      </div>

      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          Password
        </label>
        <input
          id="password"
          type="password"
          {...register("password", {
            required: "Password is required",
            minLength: {
              value: 8,
              message: "Password must be at least 8 characters",
            },
            pattern: {
              value: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
              message:
                "Password must contain at least one uppercase, one lowercase, and one number",
            },
          })}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
        {errors.password && (
          <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
        )}
      </div>

      <div>
        <label htmlFor="confirmPassword" className="block text-sm font-medium">
          Confirm Password
        </label>
        <input
          id="confirmPassword"
          type="password"
          {...register("confirmPassword", {
            required: "Please confirm your password",
            validate: (value) => value === password || "Passwords do not match",
          })}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
        {errors.confirmPassword && (
          <p className="mt-1 text-sm text-red-600">
            {errors.confirmPassword.message}
          </p>
        )}
      </div>

      {/* Hidden reCAPTCHA field */}
      <input type="hidden" {...register("recaptcha")} />

      <button
        type="submit"
        disabled={isSubmitting}
        className="w-full rounded-md bg-blue-500 px-4 py-2 text-white hover:bg-blue-600 disabled:opacity-50"
      >
        {isSubmitting ? "Registering..." : "Register"}
      </button>
    </form>
  );
}
```

## Compound pattern

The compound pattern is a way to create a component that is a composition of multiple components. It is a way to keep the components clean and modular. Let's say we want to create a `Tabs` component. It consists of two main parts:

- The list of tabs: it shows all the available tabs, which tab is currently active (selected), and allows the user to switch between tabs.
- The content of the tabs: it shows the content of the currently active tab.

### Without compound pattern

A straightforward approach is to create a single component that handles both the list of tabs and the content of the tabs.

```tsx title="tabs.tsx" lineNumbers
const Tabs = ({
  tabs,
}: {
  tabs: {
    key: string;
    label: string;
    content: React.ReactNode;
    isActive: boolean;
  }[];
}) => {
  const [activeTab, setActiveTab] = useState(
    tabs.find((tab) => tab.isActive)?.key
  );
  return (
    <div className="flex flex-col gap-2">
      <div className="flex flex-row gap-2">
        {tabs.map((tab) => {
          const isActive = tab.key === activeTab;
          return (
            <button
              key={tab.key}
              onClick={() => setActiveTab(tab.key)}
              className={cn(
                isActive ? "bg-blue-500 text-white" : "bg-gray-500 text-white"
              )}
            >
              {tab.label}
            </button>
          );
        })}
      </div>
      <div>{tabs.find((tab) => tab.key === activeTab)?.content}</div>
    </div>
  );
};
```

Then we can use the `Tabs` component like this:

```tsx title="component.tsx" lineNumbers
const Component = () => {
  return (
    <Tabs
      tabs={[
        {
          key: "tab1",
          label: "Tab 1",
          content: <div>Tab 1 content</div>,
          isActive: true,
        },
        {
          key: "tab2",
          label: "Tab 2",
          content: <div>Tab 2 content</div>,
          isActive: false,
        },
        {
          key: "tab3",
          label: "Tab 3",
          content: <div>Tab 3 content</div>,
          isActive: false,
        },
      ]}
    />
  );
};
```

The problem with this approach is that the `Tabs` component is getting too complex and it has no separation of concerns. It is responsible for both the list of tabs and the content of the tabs. It is also responsible for the state management of the active tab. It is also responsible for the logic to switch between tabs. It simply does too much.

### With compound pattern

We can use the compound pattern to break down the `Tabs` component into smaller components that are responsible for a single responsibility:

- The `Tabs` component: the parent component that manages the state and delegates rendering to the child components.
- The `TabList` component: the component that renders the list of tabs.
- The `Tab` component: the component that renders a single tab.
- The `TabPanels` component: the component that renders the content of the tabs.
- The `TabPanel` component: the component that renders the content of the currently active tab.

```tsx title="tabs.tsx" lineNumbers
// Create a context to share state between components
const TabsContext = createContext(null);

// Parent component manages state but delegates rendering
const Tabs = ({ children, defaultActiveKey }) => {
  const [activeKey, setActiveKey] = useState(defaultActiveKey);

  return (
    <TabsContext.Provider value={{ activeKey, setActiveKey }}>
      <div className="tabs-container">{children}</div>
    </TabsContext.Provider>
  );
};

// Child components with default styling
const TabList = ({ children, className = "flex flex-row gap-2" }) => {
  return <div className={className}>{children}</div>;
};

const Tab = ({ children, tabKey, disabled, className }) => {
  const { activeKey, setActiveKey } = useContext(TabsContext);
  const isActive = activeKey === tabKey;

  const defaultClassName = isActive
    ? "bg-blue-500 text-white px-4 py-2 rounded"
    : "bg-gray-500 text-white px-4 py-2 rounded";

  return (
    <button
      disabled={disabled}
      onClick={() => !disabled && setActiveKey(tabKey)}
      className={className || defaultClassName}
    >
      {children}
    </button>
  );
};

const TabPanels = ({ children, className = "mt-4" }) => {
  return <div className={className}>{children}</div>;
};

const TabPanel = ({ children, tabKey }) => {
  const { activeKey } = useContext(TabsContext);

  if (activeKey !== tabKey) return null;
  return <div className="tab-panel">{children}</div>;
};

// Attach child components to the parent
Tabs.TabList = TabList;
Tabs.Tab = Tab;
Tabs.TabPanels = TabPanels;
Tabs.TabPanel = TabPanel;
```

Then we can use the `Tabs` component with its default styling like this:

```tsx title="component.tsx" lineNumbers
<Tabs defaultActiveKey="tab1">
  <Tabs.TabList>
    <Tabs.Tab tabKey="tab1">First Tab</Tabs.Tab>
    <Tabs.Tab tabKey="tab2">Second Tab</Tabs.Tab>
    <Tabs.Tab tabKey="tab3" disabled>
      Disabled Tab
    </Tabs.Tab>
  </Tabs.TabList>

  <Tabs.TabPanels>
    <Tabs.TabPanel tabKey="tab1">
      <p>Content for first tab</p>
    </Tabs.TabPanel>
    <Tabs.TabPanel tabKey="tab2">
      <p>Content for second tab</p>
    </Tabs.TabPanel>
    <Tabs.TabPanel tabKey="tab3">
      <p>Content for disabled tab</p>
    </Tabs.TabPanel>
  </Tabs.TabPanels>
</Tabs>
```

Or we can have `Tabs` component with custom styling like for the tabs list and the panels:

```tsx title="component.tsx" lineNumbers
<Tabs defaultActiveKey="tab1">
  <Tabs.TabList className="flex flex-col space-y-2 border-r pr-4">
    <Tabs.Tab
      tabKey="tab1"
      className="text-left hover:bg-gray-100 px-4 py-2 rounded-l"
    >
      First Tab
    </Tabs.Tab>
    <Tabs.Tab
      tabKey="tab2"
      className="text-left hover:bg-gray-100 px-4 py-2 rounded-l"
    >
      Second Tab
    </Tabs.Tab>
  </Tabs.TabList>

  <Tabs.TabPanels className="pl-4 flex-1">
    <Tabs.TabPanel tabKey="tab1">
      <p>Content for first tab</p>
    </Tabs.TabPanel>
    <Tabs.TabPanel tabKey="tab2">
      <p>Content for second tab</p>
    </Tabs.TabPanel>
  </Tabs.TabPanels>
</Tabs>
```

With compound pattern, we have a clear separation of concerns and more flexibility.

<Callout type="info" title="Rule of thumb">
  Always aim to keep the component simple with minimum responsibility. Use the
  compound pattern to further break down the component into smaller components
  that are responsible for a single responsibility.
</Callout>

## Ground Rules

|     | Action                                                                                |
| --- | ------------------------------------------------------------------------------------- |
| ✅  | Don't use useEffect unnecessarily. Compute the value if possible.                     |
| ✅  | Always encapsulate the logic in a custom hook.                                        |
| ✅  | Do not create inline functions that return JSX. Instead, create a separate component. |
| ✅  | Use HOC to further reduce the complexity of a component.                              |
| ✅  | Be cautious about adding states to a component.                                       |
| ✅  | Use uncontrolled inputs in forms when possible.                                       |
| ✅  | Use compound pattern to have a clear separation of concerns and more flexibility.     |

## Todos

- Search for or create a linter rule to enforce the rule: "A React component **must not** have any `useState` and `useEffect` statements. All the state management and effect handling should be encapsulated in custom hooks." Doc: [React](../guide/react.mdx)
- Search for or create a linter rule to enforce the rule: "Do not create inline functions that return JSX. Instead, create a separate component." Doc: [React](../guide/react.mdx)
