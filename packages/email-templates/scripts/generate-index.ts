import fs from "node:fs";
import path from "node:path";

interface TemplateEntry {
  key: string;
  componentName: string;
  propsTypeName: string;
  importPath: string;
}

/**
 * Recursively finds all `.tsx` template files under the given directory,
 * excluding test files (`*.test.tsx`).
 *
 * @param dir - The directory to scan.
 * @param baseDir - The root directory used to compute relative paths.
 * @returns Sorted array of absolute file paths.
 */
export const findTemplateFiles = (
  dir: string,
  baseDir: string = dir,
): string[] => {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files: string[] = [];

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...findTemplateFiles(fullPath, baseDir));
    } else if (
      entry.name.endsWith(".tsx") &&
      !entry.name.endsWith(".test.tsx")
    ) {
      files.push(fullPath);
    }
  }

  return files.sort();
};

/**
 * Extracts the exported component name and props type name from a template
 * file's content using regex. Expects the conventions:
 * - `export interface FooProps { ... }`
 * - `export const Foo = ...`
 *
 * @param content - The file content to parse.
 * @returns The component and props type names, or `null` if not found.
 */
export const extractExports = (
  content: string,
): { componentName: string; propsTypeName: string } | null => {
  const propsMatch = content.match(/export interface (\w+Props)/);
  const componentMatch = content.match(/export const (\w+)\s*=/);

  if (!propsMatch?.[1] || !componentMatch?.[1]) {
    return null;
  }

  return {
    componentName: componentMatch[1],
    propsTypeName: propsMatch[1],
  };
};

/**
 * Builds a sorted array of template entries from the discovered files.
 *
 * @param files - Absolute paths to template files.
 * @param srcDir - The `src/` directory root, used to derive template keys and import paths.
 * @returns Array of template entries with key, component name, props type, and import path.
 */
export const buildEntries = (
  files: string[],
  srcDir: string,
): TemplateEntry[] => {
  const entries: TemplateEntry[] = [];

  for (const file of files) {
    const content = fs.readFileSync(file, "utf-8");
    const exported = extractExports(content);
    if (!exported) continue;

    const relative = path.relative(srcDir, file);
    const key = relative.replace(/\.tsx$/, "");
    const importPath = "./" + key;

    entries.push({
      key,
      componentName: exported.componentName,
      propsTypeName: exported.propsTypeName,
      importPath,
    });
  }

  return entries.sort((a, b) => a.key.localeCompare(b.key));
};

/**
 * Generates the content of `src/index.ts` from the given template entries.
 *
 * @param entries - The sorted template entries to include.
 * @returns The full file content string for `src/index.ts`.
 */
export const generateIndexContent = (entries: TemplateEntry[]): string => {
  const imports = entries
    .map(
      (e) =>
        `import { ${e.componentName}, type ${e.propsTypeName} } from "${e.importPath}";`,
    )
    .join("\n");

  const reExports = entries
    .map((e) => `export { ${e.componentName}, type ${e.propsTypeName} };`)
    .join("\n");

  const templateMapEntries = entries
    .map((e) => `  "${e.key}": ${e.propsTypeName};`)
    .join("\n");

  const templatesObjectEntries = entries
    .map((e) => `  "${e.key}": ${e.componentName},`)
    .join("\n");

  return `// @generated by scripts/generate-index.ts -- DO NOT EDIT

${imports}

${reExports}

export type TemplateMap = {
${templateMapEntries}
};

export const templates: {
  [K in keyof TemplateMap]: React.ComponentType<TemplateMap[K]>;
} = {
${templatesObjectEntries}
};
`;
};

/**
 * Main entry point: scans the src/ directory for template files and writes
 * the generated index.ts.
 *
 * @param srcDir - Path to the src/ directory. Defaults to the package's src/.
 * @param outputPath - Path to write the generated file. Defaults to src/index.ts.
 */
export const generate = (
  srcDir: string = path.resolve(__dirname, "..", "src"),
  outputPath: string = path.resolve(__dirname, "..", "src", "index.ts"),
): void => {
  const files = findTemplateFiles(srcDir);
  const entries = buildEntries(files, srcDir);
  const content = generateIndexContent(entries);
  fs.writeFileSync(outputPath, content, "utf-8");
};

const isDirectRun =
  process.argv[1] && path.resolve(process.argv[1]) === path.resolve(__filename);

if (isDirectRun) {
  generate();
}
