#!/usr/bin/env node

import fs from "fs";
import path from "path";
import { glob } from "glob";

const CONFIG_SUFFIX = ".action-config.ts";
const CREATOR_SUFFIX = ".action-creator.ts";
const ACTION_SUFFIX = ".action.ts";

// Utility functions
export function pascalCase(str: string) {
  return str
    .replace(/(^|[-_])(\w)/g, (_, __, c) => c.toUpperCase())
    .replace(/\W/g, "");
}

export function camelCase(str: string) {
  const pascal = str
    .replace(/(^|[-_])(\w)/g, (_, __, c) => c.toUpperCase())
    .replace(/\W/g, "");
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

export function getExportNames(content: string) {
  // Find all export const ... = (allowing for whitespace)
  const exportRegex = /export\s+const\s+(\w+)/g;
  const exports: string[] = [];
  let match;
  while ((match = exportRegex.exec(content))) {
    if (match[1]) {
      exports.push(match[1]);
    }
  }
  return exports;
}

export function findHandlerValidatorRoles(exports: string[]): {
  handler: string | null;
  validator: string | null;
  roles: string | null;
} {
  let handler = null,
    validator = null,
    roles = null;
  for (const exp of exports) {
    if (exp === "roles") roles = exp;
    else if (/Handler$/.test(exp)) handler = exp;
    else if (/Validator$/.test(exp)) validator = exp;
  }
  return { handler, validator, roles };
}

export type GenerateServerActionsDeps = {
  globSync: (
    pattern: string,
    opts: { cwd: string; absolute: boolean }
  ) => string[];
  readFileSync: (file: string, encoding: string) => string;
  writeFileSync: (file: string, content: string, encoding: string) => void;
  cwd: () => string;
  now: () => Date;
};

export type GenerateServerActionsResult =
  | { success: true; generated: { creatorFile: string; actionFile: string }[] }
  | { success: false; error: string };

export function generateServerActions(
  deps: GenerateServerActionsDeps
): GenerateServerActionsResult {
  const repoRoot = deps.cwd();
  const configFiles = deps.globSync(`**/*${CONFIG_SUFFIX}`, {
    cwd: repoRoot,
    absolute: true,
  });
  if (configFiles.length === 0) {
    return { success: false, error: "No .action-config.ts files found." };
  }
  const generated: { creatorFile: string; actionFile: string }[] = [];
  for (const configFile of configFiles) {
    const dir = path.dirname(configFile);
    const base = path.basename(configFile, CONFIG_SUFFIX);
    const creatorFile = path.join(dir, base + CREATOR_SUFFIX);
    const actionFile = path.join(dir, base + ACTION_SUFFIX);
    const content = deps.readFileSync(configFile, "utf8");
    const exports = getExportNames(content);
    // console.log(`Exports found in ${configFile}:`, exports);

    const pascal = pascalCase(base);
    const camel = camelCase(pascal);

    const { handler, validator, roles } = findHandlerValidatorRoles(exports);
    if (!handler || !validator || !roles) {
      const missingExports = [];
      if (!handler) missingExports.push(`missing ${camel}Handler export`);
      if (!validator) missingExports.push(`missing ${camel}Validator export`);
      if (!roles) missingExports.push("missing roles export");
      return {
        success: false,
        error:
          `Error: ${configFile} is missing required export(s): ` +
          missingExports.join(", "),
      };
    }
    // Generate creator file
    const nowStr = deps.now().toISOString();
    const creatorContent = `// This file is auto-generated by the create-server-action script.
// Generated from ${configFile} at ${nowStr}.
// DO NOT EDIT THIS FILE DIRECTLY.
// No need to commit this file to your repository.
// Add *.action-creator.ts to your .gitignore.
import "server-only";
import { PrismaClient } from "@prisma/client";
import { createFormAction, createServerFunction } from "@/app/utils/server-actions";
import { ${handler}, ${validator}, ${roles} } from "./${base}${CONFIG_SUFFIX.replace(
      ".ts",
      ""
    )}";
import { prismaClient as singletonPrismaClient } from "@/prisma/prisma-client";
import {
  productionServerActionRequestContext,
  ServerActionRequestContext
} from "@/app/utils/server-actions/server-action-request-context";
import { successResponse as successResponseGlobal } from "@/app/utils/server-actions/response";

/**
 * Type-safe successResponse for this action.
 */
type Output = Awaited<ReturnType<typeof ${handler}>> extends { data: infer D } ? D : never;
type Input = Parameters<typeof ${handler}> extends [infer P, ...any[]] ? P : undefined;
export const successResponse = (data: Output, input?: Input | null) => successResponseGlobal<Output, Input>(data, input);

export const create${pascal}FormAction = (prisma: PrismaClient = singletonPrismaClient, serverActionContext: () => Promise<ServerActionRequestContext> = productionServerActionRequestContext) => {
  return createFormAction(${validator}, ${handler}, ${roles}, prisma, serverActionContext);
};

export const create${pascal}ServerFunction = (prisma: PrismaClient = singletonPrismaClient, serverActionContext: () => Promise<ServerActionRequestContext> = productionServerActionRequestContext) => {
  return createServerFunction(${validator}, ${handler}, ${roles}, prisma, serverActionContext);
};
`;
    deps.writeFileSync(creatorFile, creatorContent, "utf8");
    // Generate action file
    const actionContent = `// This file is auto-generated by the create-server-action script.
// Generated from ${configFile} at ${nowStr}.
// DO NOT EDIT THIS FILE DIRECTLY.
// No need to commit this file to your repository.
// Add *.action.ts to your .gitignore.
"use server";

import { create${pascal}FormAction, create${pascal}ServerFunction } from "./${base}${CREATOR_SUFFIX.replace(
      ".ts",
      ""
    )}";

/**
 * To use this action in a client component, use useActionState hook or useResettableActionState hook
 */
export const ${camel}FormAction = create${pascal}FormAction();

/**
 * To use this function in a client component, call this function inside a startTransition. E.g.,
 * 
 * import { useTransition } from "react";
 * 
 * const [pending, startTransition] = useTransition();
 * <Button onClick={() => {
 *   startTransition(() => {
 *     ${camel}ServerFunction({
 *       /// payload here
 *     });
 *   });
 * }}>
 *   ${camel}
 * </Button>
 */
export const ${camel}ServerFunction = create${pascal}ServerFunction();
`;
    deps.writeFileSync(actionFile, actionContent, "utf8");
    generated.push({ creatorFile, actionFile });
  }
  return { success: true, generated };
}

// Check if this file is being run directly (not imported)
// For ES modules bin scripts, we check various conditions to determine if we're the entry point
import { fileURLToPath } from "url";
import { resolve } from "path";

const isMainModule = (() => {
  // If no argv[1], we're likely imported
  if (!process.argv[1]) return false;

  try {
    const currentFile = fileURLToPath(import.meta.url);
    const mainFile = fileURLToPath(`file://${process.argv[1]}`);

    // Direct path match
    if (currentFile === mainFile) return true;

    // Check if paths resolve to the same file (handles symlinks, different formats)
    const resolvedCurrent = resolve(currentFile);
    const resolvedMain = resolve(mainFile);
    if (resolvedCurrent === resolvedMain) return true;

    // Check if the script name appears in argv[1] (works for bin scripts via pnpm/node)
    if (
      process.argv[1]?.includes("route-action-gen") ||
      process.argv[1]?.includes("cli/index.js") ||
      mainFile.includes("route-action-gen") ||
      mainFile.includes("cli/index.js")
    ) {
      return true;
    }

    return false;
  } catch {
    // Fallback: if script name is in the path, assume it's the main module
    return (
      process.argv[1]?.includes("route-action-gen") ||
      process.argv[1]?.includes("cli/index.js") ||
      false
    );
  }
})();

if (isMainModule) {
  // CLI entrypoint
  const result = generateServerActions({
    globSync: glob.sync,
    readFileSync: (file, encoding) =>
      fs.readFileSync(file, encoding as BufferEncoding),
    writeFileSync: (file, content, encoding) =>
      fs.writeFileSync(file, content, encoding as BufferEncoding),
    cwd: process.cwd,
    now: () => new Date(),
  });
  if (!result.success) {
    console.error(result.error);
    process.exit(1);
  }
  for (const g of result.generated) {
    console.log(`Generated: ${g.creatorFile}, ${g.actionFile}`);
  }
}
