/**
 * Next.js App Router framework generator.
 *
 * Generates files for:
 * - route.ts (HTTP method handlers)
 * - client.ts (RouteClient class for non-React usage)
 * - use-route-[method].tsx (React hooks per method)
 * - server.function.ts (Server function wrapper, body methods only)
 * - form.action.ts (Form action wrapper, body methods only)
 * - use-server-function.tsx (React hook for server function, body methods only)
 * - use-form-action.tsx (React hook for form action, body methods only)
 * - form-components.tsx (React form input/label components)
 */

import type {
  FrameworkGenerator,
  GenerationContext,
  GeneratedFile,
  ParsedConfig,
} from "../types";
import { BODY_METHODS } from "../types";
import {
  pascalCase,
  buildFetchUrlExpression,
  extractDynamicSegments,
  zodTypeToInputType,
  fieldNameToLabel,
} from "../utils";

const GENERATED_HEADER =
  "/** THIS FILE IS AUTOMATICALLY GENERATED BY ROUTE-ACTION-GEN **/";

export class NextAppRouterGenerator implements FrameworkGenerator {
  name = "next-app-router";

  resolveRoutePath(directory: string): string {
    // Find the 'app/' segment in the path and use everything after it
    const appIndex = directory.indexOf("/app/");
    if (appIndex !== -1) {
      return directory.slice(appIndex + "/app".length);
    }
    // Fallback: use the last path segment
    const parts = directory.split("/");
    return "/" + parts[parts.length - 1];
  }

  generate(context: GenerationContext): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    const { configs, routePath } = context;

    // Always generate route.ts and client.ts
    files.push(this.generateRoute(configs));
    files.push(this.generateClient(configs, routePath));

    // Generate use-route-[method].tsx for each method
    for (const config of configs) {
      files.push(this.generateUseRouteHook(config, routePath));
    }

    // Find body methods (POST, PUT, PATCH) for server function / form action generation
    const bodyConfigs = configs.filter((c) => BODY_METHODS.includes(c.method));

    if (bodyConfigs.length > 0) {
      // Use the first body method config for server function, form action, and hooks
      const primaryBodyConfig = bodyConfigs[0]!;

      files.push(this.generateServerFunction(primaryBodyConfig));
      files.push(this.generateFormAction(primaryBodyConfig));
      files.push(this.generateUseServerFunction(primaryBodyConfig));
      files.push(this.generateUseFormAction(primaryBodyConfig));

      // Generate form-components if there are body or param fields
      const allBodyFields = bodyConfigs.flatMap((c) => c.bodyFields);
      const allParamFields = bodyConfigs.flatMap((c) => c.paramFields);
      if (allBodyFields.length > 0 || allParamFields.length > 0) {
        files.push(this.generateFormComponents(primaryBodyConfig));
      }
    }

    return files;
  }

  // ---------------------------------------------------------------------------
  // route.ts
  // ---------------------------------------------------------------------------
  private generateRoute(configs: ParsedConfig[]): GeneratedFile {
    const imports: string[] = [];
    const exports: string[] = [];

    // Import createRoute
    imports.push(`import { createRoute } from "route-action-gen/lib/next";`);

    for (const config of configs) {
      const method = config.method;
      const methodUpper = method.toUpperCase();
      const prefix = method;

      imports.push(
        `import {\n  handler as ${prefix}Handler,\n  requestValidator as ${prefix}RequestValidator,\n  responseValidator as ${prefix}ResponseValidator,\n} from "../${config.configFileName.replace(".ts", "")}";`,
      );

      exports.push(
        `export const ${methodUpper} = createRoute(\n  ${prefix}RequestValidator,\n  ${prefix}ResponseValidator,\n  ${prefix}Handler\n);`,
      );
    }

    const content = [GENERATED_HEADER, "", ...imports, "", ...exports, ""].join(
      "\n",
    );

    return { fileName: "route.ts", content };
  }

  // ---------------------------------------------------------------------------
  // client.ts
  // ---------------------------------------------------------------------------
  private generateClient(
    configs: ParsedConfig[],
    routePath: string,
  ): GeneratedFile {
    const imports: string[] = [GENERATED_HEADER];
    const methods: string[] = [];

    // Collect imports per config
    for (const config of configs) {
      const prefix = config.method;
      const importParts: string[] = [];
      importParts.push(`requestValidator as ${prefix}RequestValidator`);
      importParts.push(`responseValidator as ${prefix}ResponseValidator`);
      imports.push(
        `import {\n  ${importParts.join(",\n  ")},\n} from "../${config.configFileName.replace(".ts", "")}";`,
      );
    }

    imports.push(`import { z } from "zod";`);

    // Generate methods
    for (const config of configs) {
      methods.push(this.generateClientMethod(config, routePath));
    }

    const content = [
      ...imports,
      "",
      "/**",
      " * The client class that can be used to call the route handler from a non-React app.",
      " *",
      " * @returns The client class.",
      " */",
      "export class RouteClient {",
      ...methods,
      "}",
      "",
    ].join("\n");

    return { fileName: "client.ts", content };
  }

  private generateClientMethod(
    config: ParsedConfig,
    routePath: string,
  ): string {
    const prefix = config.method;
    const isBodyMethod = BODY_METHODS.includes(config.method);

    // Build input type
    const inputFields: string[] = [];
    if (isBodyMethod && config.hasBody) {
      inputFields.push(
        `    body: z.infer<NonNullable<(typeof ${prefix}RequestValidator)["body"]>>;`,
      );
    }
    if (config.hasParams) {
      inputFields.push(
        `    params: z.infer<NonNullable<(typeof ${prefix}RequestValidator)["params"]>>;`,
      );
    }
    if (config.hasSearchParams) {
      inputFields.push(
        `    searchParams: z.infer<NonNullable<(typeof ${prefix}RequestValidator)["searchParams"]>>;`,
      );
    }

    const inputType =
      inputFields.length > 0
        ? `inputData: {\n${inputFields.join("\n")}\n  }`
        : "";

    // Build fetch URL
    const fetchUrl = buildFetchUrlExpression(routePath, "inputData.params");

    // Build search params string
    let searchParamsCode = "";
    if (config.hasSearchParams) {
      searchParamsCode = `\n    const searchParams = new URLSearchParams(inputData.searchParams).toString();\n    const fetchURL = ${fetchUrl.slice(0, -1)}?\${searchParams}\`;`;
    }

    // Build fetch options
    const fetchOptions: string[] = [`      method: "${config.method}",`];
    if (isBodyMethod) {
      fetchOptions.push(`      credentials: "include",`);
      if (config.hasBody) {
        fetchOptions.push(`      body: JSON.stringify(inputData.body),`);
        fetchOptions.push(
          `      headers: {\n        "Content-Type": "application/json",\n      },`,
        );
      }
    }

    const fetchUrlVar = config.hasSearchParams ? "fetchURL" : fetchUrl;

    const lines = [
      `  /**`,
      `   * The ${config.method} method that can be used to call the route handler from a non-React app.`,
      `   */`,
      `  async ${config.method}(${inputType}): Promise<z.infer<typeof ${prefix}ResponseValidator>> {`,
    ];

    if (searchParamsCode) {
      lines.push(searchParamsCode);
    }

    lines.push(
      `    const response = await fetch(${fetchUrlVar}, {`,
      ...fetchOptions,
      `    });`,
      "",
      `    if (!response.ok) {`,
      `      throw new Error(response.statusText);`,
      `    }`,
      "",
      `    const responseData = await response.json();`,
      `    const validatedData = await ${prefix}ResponseValidator.parseAsync(responseData);`,
    );

    if (config.method === "get") {
      lines.push(`    return validatedData;`);
    } else {
      lines.push("", `    return validatedData;`);
    }

    lines.push(`  }`, "");

    return lines.join("\n");
  }

  // ---------------------------------------------------------------------------
  // use-route-[method].tsx
  // ---------------------------------------------------------------------------
  private generateUseRouteHook(
    config: ParsedConfig,
    routePath: string,
  ): GeneratedFile {
    const method = config.method;

    if (method === "get") {
      return this.generateUseRouteGetHook(config, routePath);
    }

    return this.generateUseRouteMutationHook(config, routePath);
  }

  private generateUseRouteGetHook(
    config: ParsedConfig,
    routePath: string,
  ): GeneratedFile {
    const dynamicSegments = extractDynamicSegments(routePath);

    // Build input type fields
    const inputFields: string[] = [];
    if (config.hasParams) {
      inputFields.push(
        `  params: z.infer<NonNullable<typeof requestValidator.params>>;`,
      );
    }
    if (config.hasSearchParams) {
      inputFields.push(
        `  searchParams: z.infer<NonNullable<typeof requestValidator.searchParams>>;`,
      );
    }

    const inputType =
      inputFields.length > 0 ? `input: {\n${inputFields.join("\n")}\n}` : "";

    // Build the fetch URL construction
    let fetchUrlCode: string;
    const baseUrl = routePath.replace(
      /\[(\w+)\]/g,
      (_, name) => `\${input.params.${name}}`,
    );

    if (config.hasSearchParams) {
      fetchUrlCode = `      const fetchURL = \`\${url}${baseUrl}?\${searchParamsString}\`;`;
    } else {
      fetchUrlCode = `      const fetchURL = \`\${url}${baseUrl}\`;`;
    }

    // Build useEffect dependency array
    const effectDeps: string[] = [];
    for (const seg of dynamicSegments) {
      effectDeps.push(`input.params.${seg}`);
    }
    if (config.hasSearchParams) {
      effectDeps.push("searchParamsString");
    }
    effectDeps.push("lastFetchedAt");

    const content = `${GENERATED_HEADER}
import { requestValidator, responseValidator } from "../${config.configFileName.replace(".ts", "")}";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { z } from "zod";

/**
 * A custom hook to use the route get that executes the handler function in the \`${config.configFileName}\` file.
 *
 * @param input - The input object with the params and search params.
 * @returns An object with the \`data\`, \`error\`, \`isLoading\`, \`cancel\`, \`refetch\`, and \`lastFetchedAt\` properties.
 */
export const useRouteGet = (${inputType}) => {
  const [data, setData] = useState<z.infer<typeof responseValidator> | null>(
    null
  );
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setLoading] = useState(false);
  const abortControllerRef = useRef<AbortController | null>(null);
  const [lastFetchedAt, setLastFetchedAt] = useState<number | null>(null);
  const isMountedRef = useRef(false);
${config.hasSearchParams ? "\n  const searchParamsString = new URLSearchParams(input.searchParams).toString();\n" : ""}
  // Initialize lastFetchedAt on mount to prevent hydration errors
  // This ensures the initial value is consistent between server and client
  useEffect(() => {
    if (!isMountedRef.current) {
      isMountedRef.current = true;
      setLastFetchedAt(Date.now());
    }
  }, []);

  useEffect(() => {
    // Skip fetch if lastFetchedAt hasn't been initialized yet
    if (lastFetchedAt === null) {
      return;
    }

    let isCleandUp = false;
    const thisLastFetchedAt = lastFetchedAt;

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    const fetchData = async () => {
      // reset the states
      setLoading(true);
      setError(null);
      setData(null);

      const combinedSignal = AbortSignal.any([
        abortController.signal,
        AbortSignal.timeout(1_000 * 5), // 5 seconds timeout
      ]);
      const url = window.location.protocol + "//" + window.location.host;
${fetchUrlCode}
      try {
        const response = await fetch(fetchURL, {
          signal: combinedSignal,
        });
        const data = await response.json();

        if (!isCleandUp && lastFetchedAt === thisLastFetchedAt) {
          setData(data);
          setLoading(false);
          setError(null);
        }
      } catch (error: unknown) {
        if (!isCleandUp) {
          setLoading(false);

          if (error instanceof Error && error.name === "TimeoutError") {
            setError("Timeout: It took more than 5 seconds to get the result!");
          }
          if (error instanceof Error && error.name === "AbortError") {
            setError(\`Fetch canceled by user\`);
          }
        }
      }
    };

    fetchData();

    return () => {
      isCleandUp = true;
      abortController.abort();
      abortControllerRef.current = null;
    };
  }, [${effectDeps.join(", ")}]);

  const cancel = useCallback(() => {
    abortControllerRef.current?.abort();
  }, []);

  const refetch = useCallback(() => {
    // abort the current fetch
    abortControllerRef.current?.abort();
    // set the last fetched at to the current time
    setLastFetchedAt(Date.now());
  }, []);

  return useMemo(
    () => ({ data, error, isLoading, cancel, refetch, lastFetchedAt }),
    [data, error, isLoading, cancel, refetch, lastFetchedAt]
  );
};
`;

    return { fileName: "use-route-get.tsx", content };
  }

  private generateUseRouteMutationHook(
    config: ParsedConfig,
    routePath: string,
  ): GeneratedFile {
    const method = config.method;
    const methodPascal = pascalCase(method);

    // Build input fields for the fetchData function parameter
    const inputFields: string[] = [];
    if (config.hasParams) {
      inputFields.push(
        `        params: z.infer<NonNullable<typeof requestValidator.params>>;`,
      );
    }
    if (config.hasBody) {
      inputFields.push(
        `        body: z.infer<NonNullable<typeof requestValidator.body>>;`,
      );
    }
    if (config.hasSearchParams) {
      inputFields.push(
        `        searchParams?: z.infer<NonNullable<typeof requestValidator.searchParams>>;`,
      );
    }
    inputFields.push(
      `        options?: { abortController?: AbortController; timeoutMs?: number };`,
    );

    // Build the fetch URL
    const dynamicSegments = extractDynamicSegments(routePath);
    let paramExtraction = "";
    if (dynamicSegments.length > 0 && config.hasParams) {
      const destructured = dynamicSegments.join(", ");
      paramExtraction = `      const { ${destructured} } = params;\n`;
    }

    const fetchUrlExpr = routePath.replace(
      /\[(\w+)\]/g,
      (_, name) => `\${${name}}`,
    );

    // Build fetch options
    const fetchOpts: string[] = [
      `          signal: combinedSignal,`,
      `          method: "${method}",`,
    ];
    if (BODY_METHODS.includes(method)) {
      fetchOpts.push(`          credentials: "include",`);
      if (config.hasBody) {
        fetchOpts.push(`          body: JSON.stringify(body),`);
        fetchOpts.push(
          `          headers: {\n            "Content-Type": "application/json",\n          },`,
        );
      }
    }

    // Build destructuring from inputData
    const destructParts: string[] = [];
    if (config.hasParams) destructParts.push("params");
    if (config.hasBody) destructParts.push("body");
    destructParts.push("options");

    const content = `${GENERATED_HEADER}
import { requestValidator, responseValidator } from "../${config.configFileName.replace(".ts", "")}";
import { useCallback, useMemo, useState } from "react";
import { z } from "zod";

/**
 * A custom hook to use the route ${method} that executes the handler function in the \`${config.configFileName}\` file.
 *
 * @returns An object with the \`data\`, \`error\`, \`isLoading\`, and \`fetchData\` properties.
 */
export const useRoute${methodPascal} = () => {
  const [data, setData] = useState<z.infer<typeof responseValidator> | null>(
    null
  );
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const fetchData = useCallback(
    async (
      inputData: {
${inputFields.join("\n")}
      },
      isCleanedUp?: () => boolean
    ) => {
      setIsLoading(true);
      setError(null);
      setData(null);

      const { ${destructParts.join(", ")} } = inputData;
      const { abortController = new AbortController(), timeoutMs = 10_000 } =
        options ?? {};
${paramExtraction}
      const combinedSignal = AbortSignal.any([
        abortController?.signal,
        AbortSignal.timeout(timeoutMs),
      ]);

      try {
        const response = await fetch(\`${fetchUrlExpr}\`, {
${fetchOpts.join("\n")}
        });

        if (!response.ok) {
          const error = await response.json();
          setError(new Error(error.message));
          return;
        }

        if (!isCleanedUp?.()) {
          const responseData = await response.json();

          const validatedData =
            await responseValidator.parseAsync(responseData);

          setData(validatedData);
        }
      } catch (error) {
        if (!isCleanedUp?.()) {
          if (error instanceof z.ZodError) {
            setError(new Error(error.message));
          } else {
            setError(error as Error);
          }
        }
      } finally {
        setIsLoading(false);
      }
    },
    []
  );

  return useMemo(
    () => ({ data, error, isLoading, fetchData }),
    [data, error, isLoading, fetchData]
  );
};
`;

    return { fileName: `use-route-${method}.tsx`, content };
  }

  // ---------------------------------------------------------------------------
  // server.function.ts
  // ---------------------------------------------------------------------------
  private generateServerFunction(config: ParsedConfig): GeneratedFile {
    const content = `"use server";

import {
  handler,
  requestValidator,
  responseValidator,
} from "../${config.configFileName.replace(".ts", "")}";
import { createServerFunction } from "route-action-gen/lib/next";

/**
 * The server function that executes the handler function in the \`${config.configFileName}\` file.
 *
 * @returns The server function.
 */
export const serverFunction = createServerFunction(
  requestValidator,
  responseValidator,
  handler
);
`;

    return { fileName: "server.function.ts", content };
  }

  // ---------------------------------------------------------------------------
  // form.action.ts
  // ---------------------------------------------------------------------------
  private generateFormAction(config: ParsedConfig): GeneratedFile {
    const content = `${GENERATED_HEADER}
"use server";

import {
  handler,
  requestValidator,
  responseValidator,
} from "../${config.configFileName.replace(".ts", "")}";
import { createFormAction } from "route-action-gen/lib/next";

/**
 * The form action that executes the handler function in the \`${config.configFileName}\` file.
 *
 * @returns The form action.
 */
export const formAction = createFormAction(
  requestValidator,
  responseValidator,
  handler
);
`;

    return { fileName: "form.action.ts", content };
  }

  // ---------------------------------------------------------------------------
  // use-server-function.tsx
  // ---------------------------------------------------------------------------
  private generateUseServerFunction(config: ParsedConfig): GeneratedFile {
    const content = `${GENERATED_HEADER}
"use client";

import { useCallback, useMemo, useState, useTransition } from "react";
import { responseValidator } from "../${config.configFileName.replace(".ts", "")}";
import { serverFunction } from "./server.function";
import { z } from "zod";

/**
 * A custom hook to use the server function that executes the handler function in the \`server.function.ts\` file.
 *
 * @returns An object with the \`pending\`, \`fetchData\`, \`error\`, and \`data\` properties.
 */
export const useServerFunction = () => {
  const [pending, startTransition] = useTransition();

  const [error, setError] = useState<string | null>(null);
  const [data, setData] = useState<z.infer<typeof responseValidator> | null>(
    null
  );
  const fetchData = useCallback(
    async (payload: Parameters<typeof serverFunction>[0]) => {
      startTransition(async () => {
        const result = await serverFunction(payload);
        if (result.status === false) {
          setError(result.message);
        } else {
          setData(result.data);
        }
      });
    },
    [startTransition]
  );

  return useMemo(
    () => ({
      pending,
      fetchData,
      error,
      data,
    }),
    [pending, error, data, fetchData]
  );
};
`;

    return { fileName: "use-server-function.tsx", content };
  }

  // ---------------------------------------------------------------------------
  // use-form-action.tsx
  // ---------------------------------------------------------------------------
  private generateUseFormAction(config: ParsedConfig): GeneratedFile {
    const content = `${GENERATED_HEADER}
"use client";

import { useActionState, useMemo } from "react";
import { formAction } from "./form.action";
import { createFormWithAction } from "route-action-gen/lib/react";

/**
 * A custom hook to use the form action that executes the handler function in the \`${config.configFileName}\` file.

 * @returns An object with the \`FormWithAction\`, \`state\`, and \`pending\` properties.
 */
export const useFormAction = () => {
  const [state, action, pending] = useActionState(formAction, null);
  const FormWithAction = useMemo(() => createFormWithAction(action), [action]);

  return useMemo(
    () => ({
      /**
       * The <form> React component with the action. You can add \`className\` to the form to style it.
       */
      FormWithAction,
      /**
       * The state of the action, i.e., the result of the action.
       */
      state,
      /**
       * Whether the action is pending. If true, the form is submitting.
       */
      pending,
    }),
    [FormWithAction, state, pending]
  );
};
`;

    return { fileName: "use-form-action.tsx", content };
  }

  // ---------------------------------------------------------------------------
  // form-components.tsx
  // ---------------------------------------------------------------------------
  private generateFormComponents(config: ParsedConfig): GeneratedFile {
    const fields: string[] = [];

    // Body fields
    for (const field of config.bodyFields) {
      const name = `body.${field.name}`;
      const inputType = zodTypeToInputType(field.zodType);
      const label = fieldNameToLabel(field.name);

      fields.push(
        `  "${name}": {\n` +
          `    input: createInput({\n` +
          `      name: "${name}",\n` +
          `      type: "${inputType}",\n` +
          `      id: "${name}",\n` +
          `    }),\n` +
          `    label: createLabel({ id: "${name}", placeholderChildren: "${label}" }),\n` +
          `  },`,
      );
    }

    // Param fields
    for (const field of config.paramFields) {
      const name = `params.${field.name}`;
      const inputType = zodTypeToInputType(field.zodType);
      const label = fieldNameToLabel(field.name);

      // Add minLength for string params
      const extraProps =
        field.zodType === "string" ? `\n      minLength: 1,` : "";

      fields.push(
        `  "${name}": {\n` +
          `    input: createInput({\n` +
          `      name: "${name}",\n` +
          `      type: "${inputType}",\n` +
          `      id: "${name}",${extraProps}\n` +
          `    }),\n` +
          `    label: createLabel({ id: "${name}", placeholderChildren: "${label}" }),\n` +
          `  },`,
      );
    }

    // SearchParams fields
    for (const field of config.searchParamFields) {
      const name = `searchParams.${field.name}`;
      const inputType = zodTypeToInputType(field.zodType);
      const label = fieldNameToLabel(field.name);

      fields.push(
        `  "${name}": {\n` +
          `    input: createInput({\n` +
          `      name: "${name}",\n` +
          `      type: "${inputType}",\n` +
          `      id: "${name}",\n` +
          `    }),\n` +
          `    label: createLabel({ id: "${name}", placeholderChildren: "${label}" }),\n` +
          `  },`,
      );
    }

    const content = `${GENERATED_HEADER}
"use client";
import { createInput, createLabel } from "route-action-gen/lib/react";

/**
 * The form components. The key is the name of the input field. The value is an object with the \`input\` and \`label\` components.
 * - \`input\` is the input React component and
 * - \`label\` is the label React component.
 *
 */
export const formComponents = {
${fields.join("\n")}
};
`;

    return { fileName: "form-components.tsx", content };
  }
}
